<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>My work out routine, The Reddit PPL</title>
  <meta name="description" content="Here is the work out i am doing.">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="eyejaeplas.com/fitness/current-work-out-160316.html">
  <link rel="alternate" type="application/rss+xml" title="eyejae Plas" href="eyejaeplas.com/feed.xml">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,700' rel='stylesheet' type='text/css'>
  <link href='https://fonts.googleapis.com/css?family=Merriweather:400,300italic,400italic,300,700italic,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css">
</head>

  
  <div class="wrapper" style="padding-bottom: 25px">

    <a class="site-header" href="/">eyejae Plas</a>
    <div class="text-center header-sub">
      <a href="/info/">Info</a>
      <a href="/music/">Music</a>
      <!--a href="#">Film</a-->
      <a href="/photo/">Photo</a>
      <a href="/food/">Food</a>
      <a href="/work/">Work</a>
      <!--a href="#">Lifestyle</a-->
    </div>


  </div>


  <body>



      <div class="row" style="margin-top: 80px;" id="content">
        <div class="medium-7 medium-offset-1 columns">

          <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">My work out routine, The Reddit PPL</h1>
    <p class="post-meta"><time datetime="2016-03-15T20:44:59-07:00" itemprop="datePublished">Mar 15, 2016</time> • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name">Ivan J. Plas</span></span></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>Here is the work out i am doing.</p>

<p>The post goes into detail of: what to do, How to do it, how to better it, and when to change. It is a great comprehensive guide for people who want to get big, but don’t know how.</p>

<p>The following is a post made by Reddit user <em>Metallicadpa</em> See original post <strong><em><a href="https://www.reddit.com/r/Fitness/comments/37ylk5/a_linear_progression_based_ppl_program_for/">here</a></em></strong></p>

<hr />

<p>To start, a motivational quote:</p>

<blockquote>
  <p>Errybody wanna be a bodybuilder, but nobody wanna lift this heavy-ass weight.</p>
</blockquote>

<p>R. Coleman.</p>

<p>Anyway, there seems to be a bit of a conflict between conventional training wisdom for beginners (3 day a week full body linear progression! SS/SL/Greyskull only!) and what beginners actually wanna do (in the gym every day, biceps and triceps, woo!). What I’m going to write here is an attempt to reconcile these two ideas and produce a sane way for a beginner to train more frequently and give the attention to the glamour muscles that they want, while also progressing in a correct, appropriate manner. To do this, I’m going to borrow wisdom from a few different programs and ideas. My goal is to provide an accessible program for beginners with enough volume to stimulate growth in the bro muscles, while also giving enough intensity in the main movements to elicit strength adaptations.</p>

<p><strong>First, some nomenclature:</strong></p>

<p>3x10 - in this case, it reads <em>three sets of ten repetitions</em></p>

<p>2x5, 1x5+  - this reads as, <em>two sets of 5, one set of at least 5, but as many as possible</em> (more to come on this later)</p>

<p>SS - this reads as <em>superset</em> (two exercises performed back to back with no rest in between. <strong>SUPASET</strong>)</p>

<p>BB - <em>barbell</em></p>

<p>DB - <em>dumbbell</em></p>

<p><strong>WOAH, WHAT DO YOU MEAN BY ACCESSORY WORK AND MAIN LIFTS?</strong></p>

<p>The main lifts are just the first exercises of the day, and these are always going to be done heavier than the other lifts of that day. The lifts that follow are accessory lifts, designed to build muscle, balance out weakpoints and improve your strength in the main lifts.</p>

<p><strong>BUT I DON’T CARE ABOUT STRENGTH, I JUST WANNA BE JACKED AND TAN</strong></p>

<p>Who doesn’t wanna be jacked and tan, I mean honestly? But strength progression is important, especially as a novice, for making you more muscular. Generally speaking, the more you can lift, the bigger you’ll be. Progressing your main lifts will also have carryover effects to your other lifts as well: if you can bench press 300lbs, you can sure as hell bet that you’re not gonna be incline dumbbell pressing 20lbs. And who do you really think is gonna be bigger: the version of you who can bench 200lbs, or the version of you who can bench 300lbs?</p>

<p><strong>WHAT IS LINEAR PROGRESSION?</strong></p>

<p>Put simply, linear progression means that if you were to graph your weights, the line that you would end up drawing would be straight.</p>

<p>Like this</p>

<p><img src="http://i.imgur.com/yX67l03.png" alt="1" /></p>

<p>This means that you need to add weight workout to workout, every workout. You can make progress very quickly this way <em>if you’re a beginner</em> because your body doesn’t need much stimulus to adapt. As you get more advanced, you need more stimulus and more time to adapt.</p>

<p>See this handy graph from Starting Strength to get a better understanding of what I mean.</p>

<p><img src="http://startingstrength.com/articles/figure1te.jpg" alt="2" /></p>

<p><strong>WHAT IS PPL?</strong></p>

<p>PPL is just the initialiasm of <em>push, pull, legs</em> or <em>pull, push, legs</em> (it really doesn’t matter which). This will (typically) have you doing 3 workouts, 2 times per week.</p>

<ul>
  <li>
    <p><strong>Push</strong> - this can just be thought of as moving things <em>away</em> from your body (think of a bench press)</p>
  </li>
  <li>
    <p><strong>Pull</strong> - this can be thought of as moving things <em>towards</em> your body (think of a row)</p>
  </li>
  <li>
    <p><strong>Legs</strong> - I’m not going to bother with an explanation here</p>
  </li>
</ul>

<p><strong>WHY DO I NEED TO PROGRESS LIKE THIS?</strong></p>

<p><a href="http://en.wikipedia.org/wiki/Progressive_overload" target="_blank">Because of progressive overload</a>. Without this, you won’t make any adaptations (strength gains or size gains).</p>

<p>You will always start the day with a heavy barbell exercise, and this is what you need to progress linearly (if you remember from above, this means add weight every session). Then afterwards you will follow up with higher repetition exercises, that are more ‘bodybuilding’ based.</p>

<p><strong>WHAT IS THE PROGRAM?</strong></p>

<p>It’s 6 days a week. You can run it one of two ways: <strong>PPLRPPL</strong> or <strong>PPLPPLR</strong> (where R denotes a rest day) depending on your schedule and preferences: it really makes no difference. Personally, I would run the program in the Pull, Push, Legs order.</p>

<p><strong>YOU SAY TO ADD WEIGHT LINEARLY, BUT HOW MUCH WEIGHT DO YOU ADD PER SESSION?</strong></p>

<ul>
  <li>
    <p>2.5kg/5lbs for upper body lifts (bench press, row, overhead press)</p>
  </li>
  <li>
    <p>2.5kg/5lbs for squats</p>
  </li>
  <li>
    <p>5kg/10lbs for deadlifts</p>
  </li>
</ul>

<p>Now, without further ado…</p>

<p><strong>PULL</strong></p>

<p>Deadlifts 1x5+/Barbell rows 4x5, 1x5+ (alternate, so if you did deadlifts on Monday, you would do rows on Thursday, and so on)</p>

<p>3x8-12 Pulldowns OR Pullups OR chinups</p>

<p>3x8-12 seated cable rows OR chest supported rows</p>

<p>5x15-20 face pulls</p>

<p>4x8-12 hammer curls</p>

<p>4x8-12 dumbbell curls</p>

<p><strong>PUSH</strong></p>

<p>4x5, 1x5+ bench press/4x5, 1x5+ overhead press (alternate in the same fashion as the rows and deadlifts)</p>

<p>3x8-12 overhead press/3x8-12 bench press (do the opposite movement: if you bench pressed first, overhead press here)</p>

<p>3x8-12 incline dumbbell press</p>

<p>3x8-12 triceps pushdowns SS 3x15-20 lateral raises</p>

<p>3x8-12 overhead triceps extensions SS 3x15-20 lateral raises</p>

<p><strong>LEGS</strong></p>

<p>2x5, 1x5+ squat</p>

<p>3x8-12 Romanian Deadlift</p>

<p>3x8-12 leg press</p>

<p>3x8-12 leg curls</p>

<p>5x8-12 calf raises</p>

<p><strong>FINER DETAILS: AMRAP SETS AND PROGRESSION OF ACCESSORIES</strong></p>

<p>So, the first movements are done for sets of 5, and the final set is what’s known as an <em>AMRAP</em> set (As Many Reps As Possible). This doesn’t mean that you can just YOLO it and push until you can’t push anymore. By As Many Reps As Possible, it really means <em>As many reps as possible while still maintaining good form</em>. You don’t really want to be grinding too many reps, since you want to keep rep quality high. If you want a good reason to keep rep quality high, <a href="https://www.youtube.com/watch?v=oLSpdzT6sGw" target="_blank">watch this recent video from Omar Isuf</a>. The point of the AMRAP set is that it really gives you a chance to test your limits, and if you’re feeling good on a specific day, you can get in a couple of extra reps. But the real moneymaker from this comes in when you deload.</p>

<p><strong>Progression of accessories</strong> should be done as so: when you can hit 3 sets of 12 with good form, add weight. As long as you’re in the 8-12 range for your sets then you’re good. If not, lower the weight.</p>

<p><strong>HOW DO I KNOW WHAT WEIGHTS TO START WITH?</strong></p>

<p>I don’t like the Stronglifts 5x5 idea of starting with the empty bar, because I think the empty bar is useless for training purposes if you’re capable of lifting a lot more. The mechanics of a lift (especially the squat for me) change a lot with weight.</p>

<p>I would recommend starting with the bar, and gradually adding weight for sets of 5 until the bar slows down. Then back off 2.5kg/5lbs, and this is your starting point. So if you worked up to a 60kg bench press before the bar slowed down at all, start at 57.5kg.</p>

<p><strong>WARMUPS</strong></p>

<p>(idea courtesy of /u/Gawd1)</p>

<p>I’m a big believer in just practising the movement as a warmup. So you can use bench press to warm up for bench press. Or squats to warm up for squats. You get the idea. The goal of a warmup is to get blood into the muscles and joints that are going to be used, and also to start drilling the motor patterns into your body for form purposes. As an example, if you’re going to be benching 200lbs as your top set for that day, your warmups could look something like this:</p>

<p>Empty bar x 10</p>

<p>95lbs x10</p>

<p>135lbs x5</p>

<p>185lbs x3</p>

<p>200lbs 4x5, 1x5+</p>

<p>Warming up is a very individual thing, however, so do whatever you want to get yourself prepared for the lifts. If you like foam rolling, great. If you like some dynamic stretches and things like clapping pushups, great. Do whatever you want to do. The only recommendation is that I would avoid static stretches before lifting.</p>

<p><strong>REST</strong></p>

<p>Rest as long as is needed between sets. For a general guideline, I would recommend:</p>

<ul>
  <li>
    <p>3-5 minutes between your first exercise of the day</p>
  </li>
  <li>
    <p>1-3 minutes between all your other exercises</p>
  </li>
</ul>

<p>Don’t worry too much about rest times, and worry more about just getting all your sets and reps in.</p>

<p><strong>FAILURE</strong></p>

<p>Failure is part of life, and since lifting weights is a lot like life, failure is also part of lifting weights. At some point, you’re going to fail. Failure can occur really for two reasons</p>

<ul>
  <li>
    <p>not enough sleep, food or recovery: if you spent all night partying and chasing pussy with your wing man, Jim Beam, you’re probably not gonna perform well in the gym. In this case, don’t count it as a true failure and just try again next time when you’re fresh</p>
  </li>
  <li>
    <p>strength failure. This is when you’ve reached the limit of your progression. If you fail a session 3 times in a row (for example, if you fail to hit 3x5 on squats at 100kg 3 times in a row), you need to lower the weight.</p>
  </li>
</ul>

<p>This leads us to…</p>

<p><strong>DELOADING</strong></p>

<p>Deloading is exactly what it sounds like – taking weight off the bar. Take 10% off your working weights (so a 100kg squat would go back down to 90kg), and work back up. This should give you a good chance to push things on the AMRAP final sets. If you got 2x5 and 1x6 at 90kg the first time round, you can bet your ass that you’ll get more than 6 on your last set the second time round. And by the time you work your way back up, if you can hit 97.5kg for 2x5, 1x8, 100kg for 3x5 will be trivial.</p>

<p><strong>MY GYM OR GARAGE DOESN’T HAVE XYZ, WHAT CAN I DO INSTEAD?</strong></p>

<p>(this section as recommended by /u/LaRivalita)</p>

<p>So basically everything here is interchangeable, except the main lifts: the squat, bench press, deadlift, overhead press, bent over row. If you can do those in your gym (not in a smith machine) then you can make this program work. Treat it more as template than gospel. Some ideas for substitutions are the following (and if anyone has other suggestions, I’m happy to add them to the list!):</p>

<ul>
  <li>
    <p><strong>Pull substitutions</strong></p>
  </li>
  <li>
    <p>Seated cable rows can be replaced with dumbbell rows or t-bar rows</p>
  </li>
  <li>
    <p>Face pulls can be replaced with rear delt flyes AND band pull aparts (not one or the other)</p>
  </li>
  <li>
    <p>hammer curls and dumbbell curls can really be replaced by any curl variation: it’s a curl, shit ain’t that serious!</p>
  </li>
  <li>
    <p><strong>Push substitutions</strong></p>
  </li>
  <li>
    <p>incline dumbbell press can be replaced with landmine press</p>
  </li>
  <li>
    <p>triceps pushdowns and overhead extensions can be replaced with any general triceps exercise: skullcrushers, lying triceps extensions, dumbbell triceps extensions, whatever you want to do</p>
  </li>
  <li>
    <p><strong>Legs substitutions</strong></p>
  </li>
  <li>
    <p>Leg press can be substituted with front squats</p>
  </li>
  <li>
    <p>leg curls can be substituted with glute ham raises</p>
  </li>
  <li>
    <p>calf raises can be substituted by nothing because who gives a flying fuck about calves anyway? (not srs, any kind of calf raise will be fine here)</p>
  </li>
</ul>

<p><strong>HOW TO MODIFY THIS TO FIT YOUR GOALS</strong></p>

<p>(this section as recommended by /u/theedoor)</p>

<p><strong>If you want to lift heavy weights</strong></p>

<p>There are a few things I would recommend here.</p>

<p>/u/theedoor’s advice of: “for example, if you want to be focused a bit more on strength, replace 3x8-12 RDLs with 3x5 RDLs. Add weighted dips, and weighted chins-ups/pull-ups in the 3x5 range (with bodyweight back off sets).” is brilliant.</p>

<p>If you want to lift heavy weights, then you need to lift heavy weights. I know this sounds stupid, but it makes sense. The more time you spend in the lower rep ranges, the better you’re going to be in those rep ranges, so if you want to lift heavy weights then feel free to alter the compound movement accessories (so your presses, your pulldowns or rows, your romanian deadlifts or your leg presses) to be in the lower rep ranges. 3x4-6 is perfect for things like this. In my view, the isolation accessory movements should be kept in higher rep ranges, because joint wear and tear can creep in here, and getting a pump is fucking awesome.</p>

<p>Specificity is also pretty key if you want to lift heavy weights. If you want to be a good bench presser, then maybe incline dumbbell press isn’t going to be <em>as specific</em> as doing a close grip bench press instead is. If you want to substitute some of the (again, compound) accessory movements for ones that more closely resemble the main lifts, then be my guest.</p>

<p><strong>If you want to increase endurance</strong></p>

<p>Keep the first exercise the same, up the rep range on everything else. 15-20 reps is a great range for increasing endurance.</p>

<p><strong>If you just want to be jacked and tan</strong></p>

<p>Keep things the way they are. There’s enough volume and a decent enough mix of volume and strength to get you big as long as you’re eating enough. If you feel a specific bodypart is lacking, throw in a couple of extra sets for it, ideally isolation (so think along the lines of pec deck or biceps curls, not bench press or rows), so that you’re not adding too much systemic stress, which could affect recovery times.</p>

<p><strong>WHAT’S MORE IMPORTANT, FORM OR WEIGHT?</strong></p>

<p>(idea courtesy of /u/Nobody773)</p>

<p>Both. Nobody got big benching 1 plate regardless of how good their form is. You should push the weights up and continue progressing as long as your form is <em>acceptable.</em> Demanding that your form is 100% perfect all the time as a beginner is just not possible, so as long as your form is acceptable and not injurious, then continue adding weight. As an unknown lifter once said: the best way to improve your form at 225lbs is to make 225lbs part of your warmup. I can guarantee that when you’re squatting 315lbs for reps that your form at 225lbs is picture perfect.</p>

<p><strong>THIS IS COMPLICATED, THERE’S A LOT GOING ON! HOW DO I KEEP TRACK OF THIS?</strong></p>

<p>It’s something I hadn’t thought of, since I have a borderline-autistic savant memory for things I do in the gym, but <a href="https://drive.google.com/previewtemplate?id=1MbOWpTBcNNQuqHd8q9jUUR2V-ZERWNDKYPd5kzVjCJQ&amp;mode=public" target="_blank">here is spreadsheet created by /u/Mobius000</a> which will make tracking this a walk in the park.</p>

<p><strong>CAN I DO THIS PROGRAM WHILE CUTTING?</strong></p>

<p>Sure! You can do anything while cutting, so try it out. I suspect that recovery may become an issue due to the volume, so if you are struggling to recover and feeling like shit, drop some of the volume: 3x8-12 becomes 2x8-12, for example. Taper the volume off as little as possible, and keep the volume for the main lifts as high as you can for as long as you can.</p>

<p><strong>CAN I DO AB WORK ON THIS PROGRAM?</strong></p>

<p>Yes. I would recommend doing ab work on your deadlift days and your squat days if you want to do ab work. Nothing major, just do a few sets of (weighted) planks or a few sets of ab wheel and some hanging leg raises.</p>

<p><strong>NEXT STEPS</strong></p>

<p>A few people have requested this, so I thought I would write out what I think logical next steps from here are. This is a <strong>beginner</strong> routine, for beginners. Intermediate and advanced lifters can’t make linear progress like this anymore, and require some more advanced training in order to progress.</p>

<p>Questions courtesy of /u/FattestRabbit:</p>

<blockquote>
  <p><strong>What are some signs that you may want to graduate from this program?</strong></p>
</blockquote>

<p>Put simply, when you’re no longer a beginner. A beginner lifter is defined as someone who can make progress workout to workout: if you deadlift 100kg for 5 reps, then the next time you deadlift you’ll be able to deadlift 105kg for 5 reps. Once this <em>linear</em> progression stalls out, and you take longer to recover between workouts because the weights are heavier (and therefore the systemic stress is higher), you become an intermediate lifter. An intermediate lifter is someone who needs ~weekly progression in order to maintain progress (programs like the Texas Method for example).</p>

<blockquote>
  <p><strong>Can you adapt this program for ‘intermediate’ lifters? How far can this program take you if you upped the weights and moved more sets to 3x5-8 (instead of 3x8-12)?</strong></p>
</blockquote>

<p>Yes, you can adapt this program for more intermediate lifters, but I wouldn’t like to try and formalise something like that. The more advanced you get as a lifter, the more you should be realising what things are beneficial for you, and figuring out what works for you, because everyone is a bit different. In the beginner stages, this stuff really isn’t too important because almost any beginner will make progress doing almost anything. I would recommend looking at progression schemes that are in things like the <strong>Texas Method</strong>, <strong>Madcows 5x5</strong> and <strong>5/3/1</strong> for your main lifts and then just sticking with fairly similar accessory work: more volume almost always equates to better gains, provided you can recover from it.</p>

<p>Moving more sets to 3x5-8 wouldn’t necessarily have a huge impact on your abilities to lift big weights in the main lifts, and heavier sets (in my experience) tend to impose more wear and tear on the joints. If you’re an intermediate lifter then go for it, try it out, it may work for you. Intermediate lifting should be all about trying things for yourself and getting to know yourself better as a lifter.</p>

<blockquote>
  <p><strong>What are some next logical programs to try after this one?</strong></p>
</blockquote>

<p>Texas Method, Madcows 5x5, 5/3/1, PHAT, PHUL, /u/gzcl’s Jacked and Tan - any program designed towards intermediates that are in line with your goals. Pick something you think you’ll have fun with: unless this shit is your job or you really want to compete seriously then just have fun in the gym and don’t do something too retarded, and you’ll probably stick to it better than something you hate, and go to the gym with more drive and intensity. I’m a big believer that consistent effort is probably the most important thing you can make sure of. <a href="http://www.powerliftingtowin.com/" target="_blank">PowerliftingToWin</a> is a great resource for training information and programming information, so I would recommend reading a bunch there.</p>

<p><strong>CAN I DO THIS ROUTINE ONLY ONCE PER WEEK?</strong></p>

<p>You <em>could.</em> And that’s all I’m gonna say. I wouldn’t recommend it, because that’d put frequency of all the lifts at only once per week. If you can only run it once per week then I would recommend something like Greyskull LP, Stronglifts 5x5 or Starting Strength instead for increased frequency.</p>

  </div>

  <blockquote> Tags:
  
    <a href="/tags/#workout">workout</a> /
  
    <a href="/tags/#heath">heath</a> /
  
    <a href="/tags/#reddit">reddit</a> /
  


  </blockquote>

</article>


        </div>
        <div class="medium-3 columns" data-sticky-container>
          <div class="sticky" data-sticky data-anchor="content">
              <p class="post-meta">Recent Posts</p>
               <!-- for1 -->
              <span class="post-meta">
              <a href="eyejaeplas.com/test/audio.html" title="audio test">
                audio test </a><br />
                Apr 6 | <a href="/test">test</a>
              </span>
              <div style="border-bottom: thin solid #cecece;"></div>
             <!-- for1 -->
              <span class="post-meta">
              <a href="eyejaeplas.com/Quick-Tips/Converting-my-older-sites.html" title="Quick Tips: ">
                Quick Tips:  </a><br />
                Apr 3 | <a href="/QuickTips">QuickTips</a>
              </span>
              <div style="border-bottom: thin solid #cecece;"></div>
             <!-- for1 -->
              <span class="post-meta">
              <a href="eyejaeplas.com/fitness/current-work-out-160316.html" title="My work out routine, The Reddit PPL">
                My work out routine, The Reddit PPL </a><br />
                Mar 15 | <a href="/fitness">fitness</a>
              </span>
              <div style="border-bottom: thin solid #cecece;"></div>
            

            <div>

              <a class="twitter-timeline" href="https://twitter.com/eyejaePlas" data-widget-id="716367557955952640">Tweets by @eyejaePlas</a>
              <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

            </div>

          </div>
        </div>
      </div>



    <div class="row">

  <div class="large-12 columns" style="margin-bottom: 15px;">

      <div class="row">

        <div class="large-3 columns"><br></div>

        <div class="large-6 columns site-footer" align="center">

          <div class="row">

            <div class="large-5 columns site-footer-1">

              <p>Designed <i class="fa fa-laptop fa"></i> By Me</p>
              <p>Using <i class="fa fa-code fa"></i> <a href="https://jekyllrb.com/" target="_blank">Jekyll</a></p>
              <p>Stock Images <i class="fa fa-camera fa"></i> <a href="/assets/img/images.txt" target="_blank">used</a></p>

            </div>
            <div class="small-2 columns"></div>

            <div class="large-5 columns site-footer-2" align="left" style="line-height: 1.6em;">

              <i class="fa fa-twitter fa"></i>  twitter<br />
              <i class="fa fa-instagram fa"></i>  instagram<br />
              <i class="fa fa-youtube fa"></i>  youtube<br />
              <i class="fa fa-soundcloud fa"></i>  soundcloud

            </div>

          </div>

          Copyright @2016 - <a href="http://ivanjplas.com" target="_blank">Ivan J. Plas</a> - All rights reserved

        </div>

        <div class="large-3 columns"><br></div>

      </div>
  </div>
</div>

<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="http://dhbhdrzi4tiry.cloudfront.net/cdn/sites/foundation.js"></script>
<script>
      $(document).foundation();
</script>

<script charset="utf-8">

!function ($) {

"use strict";

var FOUNDATION_VERSION = '6.2.0';

// Global Foundation object
// This is attached to the window, or used as a module for AMD/Browserify
var Foundation = {
  version: FOUNDATION_VERSION,

  /**
   * Stores initialized plugins.
   */
  _plugins: {},

  /**
   * Stores generated unique ids for plugin instances
   */
  _uuids: [],

  /**
   * Returns a boolean for RTL support
   */
  rtl: function () {
    return $('html').attr('dir') === 'rtl';
  },
  /**
   * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.
   * @param {Object} plugin - The constructor of the plugin.
   */
  plugin: function (plugin, name) {
    // Object key to use when adding to global Foundation object
    // Examples: Foundation.Reveal, Foundation.OffCanvas
    var className = name || functionName(plugin);
    // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin
    // Examples: data-reveal, data-off-canvas
    var attrName = hyphenate(className);

    // Add to the Foundation object and the plugins list (for reflowing)
    this._plugins[attrName] = this[className] = plugin;
  },
  /**
   * @function
   * Populates the _uuids array with pointers to each individual plugin instance.
   * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.
   * Also fires the initialization event for each plugin, consolidating repeditive code.
   * @param {Object} plugin - an instance of a plugin, usually `this` in context.
   * @param {String} name - the name of the plugin, passed as a camelCased string.
   * @fires Plugin#init
   */
  registerPlugin: function (plugin, name) {
    var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();
    plugin.uuid = this.GetYoDigits(6, pluginName);

    if (!plugin.$element.attr(`data-${ pluginName }`)) {
      plugin.$element.attr(`data-${ pluginName }`, plugin.uuid);
    }
    if (!plugin.$element.data('zfPlugin')) {
      plugin.$element.data('zfPlugin', plugin);
    }
    /**
     * Fires when the plugin has initialized.
     * @event Plugin#init
     */
    plugin.$element.trigger(`init.zf.${ pluginName }`);

    this._uuids.push(plugin.uuid);

    return;
  },
  /**
   * @function
   * Removes the plugins uuid from the _uuids array.
   * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.
   * Also fires the destroyed event for the plugin, consolidating repeditive code.
   * @param {Object} plugin - an instance of a plugin, usually `this` in context.
   * @fires Plugin#destroyed
   */
  unregisterPlugin: function (plugin) {
    var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));

    this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);
    plugin.$element.removeAttr(`data-${ pluginName }`).removeData('zfPlugin')
    /**
     * Fires when the plugin has been destroyed.
     * @event Plugin#destroyed
     */
    .trigger(`destroyed.zf.${ pluginName }`);
    for (var prop in plugin) {
      plugin[prop] = null; //clean up script to prep for garbage collection.
    }
    return;
  },

  /**
   * @function
   * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.
   * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`
   * @default If no argument is passed, reflow all currently active plugins.
   */
  reInit: function (plugins) {
    var isJQ = plugins instanceof $;
    try {
      if (isJQ) {
        plugins.each(function () {
          $(this).data('zfPlugin')._init();
        });
      } else {
        var type = typeof plugins,
            _this = this,
            fns = {
          'object': function (plgs) {
            plgs.forEach(function (p) {
              p = hyphenate(p);
              $('[data-' + p + ']').foundation('_init');
            });
          },
          'string': function () {
            plugins = hyphenate(plugins);
            $('[data-' + plugins + ']').foundation('_init');
          },
          'undefined': function () {
            this['object'](Object.keys(_this._plugins));
          }
        };
        fns[type](plugins);
      }
    } catch (err) {
      console.error(err);
    } finally {
      return plugins;
    }
  },

  /**
   * returns a random base-36 uid with namespacing
   * @function
   * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.
   * @param {String} namespace - name of plugin to be incorporated in uid, optional.
   * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.
   * @returns {String} - unique id
   */
  GetYoDigits: function (length, namespace) {
    length = length || 6;
    return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? `-${ namespace }` : '');
  },
  /**
   * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.
   * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.
   * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.
   */
  reflow: function (elem, plugins) {

    // If plugins is undefined, just grab everything
    if (typeof plugins === 'undefined') {
      plugins = Object.keys(this._plugins);
    }
    // If plugins is a string, convert it to an array with one item
    else if (typeof plugins === 'string') {
        plugins = [plugins];
      }

    var _this = this;

    // Iterate through each plugin
    $.each(plugins, function (i, name) {
      // Get the current plugin
      var plugin = _this._plugins[name];

      // Localize the search to all elements inside elem, as well as elem itself, unless elem === document
      var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');

      // For each plugin found, initialize it
      $elem.each(function () {
        var $el = $(this),
            opts = {};
        // Don't double-dip on plugins
        if ($el.data('zfPlugin')) {
          console.warn("Tried to initialize " + name + " on an element that already has a Foundation plugin.");
          return;
        }

        if ($el.attr('data-options')) {
          var thing = $el.attr('data-options').split(';').forEach(function (e, i) {
            var opt = e.split(':').map(function (el) {
              return el.trim();
            });
            if (opt[0]) opts[opt[0]] = parseValue(opt[1]);
          });
        }
        try {
          $el.data('zfPlugin', new plugin($(this), opts));
        } catch (er) {
          console.error(er);
        } finally {
          return;
        }
      });
    });
  },
  getFnName: functionName,
  transitionend: function ($elem) {
    var transitions = {
      'transition': 'transitionend',
      'WebkitTransition': 'webkitTransitionEnd',
      'MozTransition': 'transitionend',
      'OTransition': 'otransitionend'
    };
    var elem = document.createElement('div'),
        end;

    for (var t in transitions) {
      if (typeof elem.style[t] !== 'undefined') {
        end = transitions[t];
      }
    }
    if (end) {
      return end;
    } else {
      end = setTimeout(function () {
        $elem.triggerHandler('transitionend', [$elem]);
      }, 1);
      return 'transitionend';
    }
  }
};

Foundation.util = {
  /**
   * Function for applying a debounce effect to a function call.
   * @function
   * @param {Function} func - Function to be called at end of timeout.
   * @param {Number} delay - Time in ms to delay the call of `func`.
   * @returns function
   */
  throttle: function (func, delay) {
    var timer = null;

    return function () {
      var context = this,
          args = arguments;

      if (timer === null) {
        timer = setTimeout(function () {
          func.apply(context, args);
          timer = null;
        }, delay);
      }
    };
  }
};

// TODO: consider not making this a jQuery function
// TODO: need way to reflow vs. re-initialize
/**
 * The Foundation jQuery method.
 * @param {String|Array} method - An action to perform on the current jQuery object.
 */
var foundation = function (method) {
  var type = typeof method,
      $meta = $('meta.foundation-mq'),
      $noJS = $('.no-js');

  if (!$meta.length) {
    $('<meta class="foundation-mq">').appendTo(document.head);
  }
  if ($noJS.length) {
    $noJS.removeClass('no-js');
  }

  if (type === 'undefined') {
    //needs to initialize the Foundation object, or an individual plugin.
    Foundation.MediaQuery._init();
    Foundation.reflow(this);
  } else if (type === 'string') {
    //an individual method to invoke on a plugin or group of plugins
    var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary
    var plugClass = this.data('zfPlugin'); //determine the class of plugin

    if (plugClass !== undefined && plugClass[method] !== undefined) {
      //make sure both the class and method exist
      if (this.length === 1) {
        //if there's only one, call it directly.
        plugClass[method].apply(plugClass, args);
      } else {
        this.each(function (i, el) {
          //otherwise loop through the jQuery collection and invoke the method on each
          plugClass[method].apply($(el).data('zfPlugin'), args);
        });
      }
    } else {
      //error for no class or no method
      throw new ReferenceError("We're sorry, '" + method + "' is not an available method for " + (plugClass ? functionName(plugClass) : 'this element') + '.');
    }
  } else {
    //error for invalid argument type
    throw new TypeError(`We're sorry, ${ type } is not a valid parameter. You must use a string representing the method you wish to invoke.`);
  }
  return this;
};

window.Foundation = Foundation;
$.fn.foundation = foundation;

// Polyfill for requestAnimationFrame
(function () {
  if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {
    return new Date().getTime();
  };

  var vendors = ['webkit', 'moz'];
  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {
    var vp = vendors[i];
    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];
    window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];
  }
  if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {
    var lastTime = 0;
    window.requestAnimationFrame = function (callback) {
      var now = Date.now();
      var nextTime = Math.max(lastTime + 16, now);
      return setTimeout(function () {
        callback(lastTime = nextTime);
      }, nextTime - now);
    };
    window.cancelAnimationFrame = clearTimeout;
  }
  /**
   * Polyfill for performance.now, required by rAF
   */
  if (!window.performance || !window.performance.now) {
    window.performance = {
      start: Date.now(),
      now: function () {
        return Date.now() - this.start;
      }
    };
  }
})();
if (!Function.prototype.bind) {
  Function.prototype.bind = function (oThis) {
    if (typeof this !== 'function') {
      // closest thing possible to the ECMAScript 5
      // internal IsCallable function
      throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP = function () {},
        fBound = function () {
      return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
    };

    if (this.prototype) {
      // native functions don't have a prototype
      fNOP.prototype = this.prototype;
    }
    fBound.prototype = new fNOP();

    return fBound;
  };
}
// Polyfill to get the name of a function in IE9
function functionName(fn) {
  if (Function.prototype.name === undefined) {
    var funcNameRegex = /function\s([^(]{1,})\(/;
    var results = funcNameRegex.exec(fn.toString());
    return results && results.length > 1 ? results[1].trim() : "";
  } else if (fn.prototype === undefined) {
    return fn.constructor.name;
  } else {
    return fn.prototype.constructor.name;
  }
}
function parseValue(str) {
  if (/true/.test(str)) return true;else if (/false/.test(str)) return false;else if (!isNaN(str * 1)) return parseFloat(str);
  return str;
}
// Convert PascalCase to kebab-case
// Thank you: http://stackoverflow.com/a/8955580
function hyphenate(str) {
  return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
}
}(jQuery);
'use strict';

!function ($) {

Foundation.Box = {
  ImNotTouchingYou: ImNotTouchingYou,
  GetDimensions: GetDimensions,
  GetOffsets: GetOffsets
};

/**
 * Compares the dimensions of an element to a container and determines collision events with container.
 * @function
 * @param {jQuery} element - jQuery object to test for collisions.
 * @param {jQuery} parent - jQuery object to use as bounding container.
 * @param {Boolean} lrOnly - set to true to check left and right values only.
 * @param {Boolean} tbOnly - set to true to check top and bottom values only.
 * @default if no parent object passed, detects collisions with `window`.
 * @returns {Boolean} - true if collision free, false if a collision in any direction.
 */
function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {
  var eleDims = GetDimensions(element),
      top,
      bottom,
      left,
      right;

  if (parent) {
    var parDims = GetDimensions(parent);

    bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;
    top = eleDims.offset.top >= parDims.offset.top;
    left = eleDims.offset.left >= parDims.offset.left;
    right = eleDims.offset.left + eleDims.width <= parDims.width;
  } else {
    bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;
    top = eleDims.offset.top >= eleDims.windowDims.offset.top;
    left = eleDims.offset.left >= eleDims.windowDims.offset.left;
    right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;
  }

  var allDirs = [bottom, top, left, right];

  if (lrOnly) {
    return left === right === true;
  }

  if (tbOnly) {
    return top === bottom === true;
  }

  return allDirs.indexOf(false) === -1;
};

/**
 * Uses native methods to return an object of dimension values.
 * @function
 * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.
 * @returns {Object} - nested object of integer pixel values
 * TODO - if element is window, return only those values.
 */
function GetDimensions(elem, test) {
  elem = elem.length ? elem[0] : elem;

  if (elem === window || elem === document) {
    throw new Error("I'm sorry, Dave. I'm afraid I can't do that.");
  }

  var rect = elem.getBoundingClientRect(),
      parRect = elem.parentNode.getBoundingClientRect(),
      winRect = document.body.getBoundingClientRect(),
      winY = window.pageYOffset,
      winX = window.pageXOffset;

  return {
    width: rect.width,
    height: rect.height,
    offset: {
      top: rect.top + winY,
      left: rect.left + winX
    },
    parentDims: {
      width: parRect.width,
      height: parRect.height,
      offset: {
        top: parRect.top + winY,
        left: parRect.left + winX
      }
    },
    windowDims: {
      width: winRect.width,
      height: winRect.height,
      offset: {
        top: winY,
        left: winX
      }
    }
  };
}

/**
 * Returns an object of top and left integer pixel values for dynamically rendered elements,
 * such as: Tooltip, Reveal, and Dropdown
 * @function
 * @param {jQuery} element - jQuery object for the element being positioned.
 * @param {jQuery} anchor - jQuery object for the element's anchor point.
 * @param {String} position - a string relating to the desired position of the element, relative to it's anchor
 * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.
 * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.
 * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.
 * TODO alter/rewrite to work with `em` values as well/instead of pixels
 */
function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {
  var $eleDims = GetDimensions(element),
      $anchorDims = anchor ? GetDimensions(anchor) : null;

  switch (position) {
    case 'top':
      return {
        left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
        top: $anchorDims.offset.top - ($eleDims.height + vOffset)
      };
      break;
    case 'left':
      return {
        left: $anchorDims.offset.left - ($eleDims.width + hOffset),
        top: $anchorDims.offset.top
      };
      break;
    case 'right':
      return {
        left: $anchorDims.offset.left + $anchorDims.width + hOffset,
        top: $anchorDims.offset.top
      };
      break;
    case 'center top':
      return {
        left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
        top: $anchorDims.offset.top - ($eleDims.height + vOffset)
      };
      break;
    case 'center bottom':
      return {
        left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,
        top: $anchorDims.offset.top + $anchorDims.height + vOffset
      };
      break;
    case 'center left':
      return {
        left: $anchorDims.offset.left - ($eleDims.width + hOffset),
        top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
      };
      break;
    case 'center right':
      return {
        left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,
        top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2
      };
      break;
    case 'center':
      return {
        left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,
        top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2
      };
      break;
    case 'reveal':
      return {
        left: ($eleDims.windowDims.width - $eleDims.width) / 2,
        top: $eleDims.windowDims.offset.top + vOffset
      };
    case 'reveal full':
      return {
        left: $eleDims.windowDims.offset.left,
        top: $eleDims.windowDims.offset.top
      };
      break;
    default:
      return {
        left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,
        top: $anchorDims.offset.top + $anchorDims.height + vOffset
      };
  }
}
}(jQuery);
/*******************************************
*                                         *
* This util was created by Marius Olbertz *
* Please thank Marius on GitHub /owlbertz *
* or the web http://www.mariusolbertz.de/ *
*                                         *
******************************************/

'use strict';

!function ($) {

const keyCodes = {
  9: 'TAB',
  13: 'ENTER',
  27: 'ESCAPE',
  32: 'SPACE',
  37: 'ARROW_LEFT',
  38: 'ARROW_UP',
  39: 'ARROW_RIGHT',
  40: 'ARROW_DOWN'
};

var commands = {};

var Keyboard = {
  keys: getKeyCodes(keyCodes),

  /**
   * Parses the (keyboard) event and returns a String that represents its key
   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
   * @param {Event} event - the event generated by the event handler
   * @return String key - String that represents the key pressed
   */
  parseKey(event) {
    var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();
    if (event.shiftKey) key = `SHIFT_${ key }`;
    if (event.ctrlKey) key = `CTRL_${ key }`;
    if (event.altKey) key = `ALT_${ key }`;
    return key;
  },

  /**
   * Handles the given (keyboard) event
   * @param {Event} event - the event generated by the event handler
   * @param {String} component - Foundation component's name, e.g. Slider or Reveal
   * @param {Objects} functions - collection of functions that are to be executed
   */
  handleKey(event, component, functions) {
    var commandList = commands[component],
        keyCode = this.parseKey(event),
        cmds,
        command,
        fn;

    if (!commandList) return console.warn('Component not defined!');

    if (typeof commandList.ltr === 'undefined') {
      // this component does not differentiate between ltr and rtl
      cmds = commandList; // use plain list
    } else {
        // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa
        if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);
      }
    command = cmds[keyCode];

    fn = functions[command];
    if (fn && typeof fn === 'function') {
      // execute function  if exists
      fn.apply();
      if (functions.handled || typeof functions.handled === 'function') {
        // execute function when event was handled
        functions.handled.apply();
      }
    } else {
      if (functions.unhandled || typeof functions.unhandled === 'function') {
        // execute function when event was not handled
        functions.unhandled.apply();
      }
    }
  },

  /**
   * Finds all focusable elements within the given `$element`
   * @param {jQuery} $element - jQuery object to search within
   * @return {jQuery} $focusable - all focusable elements within `$element`
   */
  findFocusable($element) {
    return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {
      if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {
        return false;
      } //only have visible elements and those that have a tabindex greater or equal 0
      return true;
    });
  },

  /**
   * Returns the component name name
   * @param {Object} component - Foundation component, e.g. Slider or Reveal
   * @return String componentName
   */

  register(componentName, cmds) {
    commands[componentName] = cmds;
  }
};

/*
 * Constants for easier comparing.
 * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE
 */
function getKeyCodes(kcs) {
  var k = {};
  for (var kc in kcs) k[kcs[kc]] = kcs[kc];
  return k;
}

Foundation.Keyboard = Keyboard;
}(jQuery);
'use strict';

!function ($) {

// Default set of media queries
const defaultQueries = {
  'default': 'only screen',
  landscape: 'only screen and (orientation: landscape)',
  portrait: 'only screen and (orientation: portrait)',
  retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
};

var MediaQuery = {
  queries: [],

  current: '',

  /**
   * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.
   * @function
   * @private
   */
  _init() {
    var self = this;
    var extractedStyles = $('.foundation-mq').css('font-family');
    var namedQueries;

    namedQueries = parseStyleToObject(extractedStyles);

    for (var key in namedQueries) {
      self.queries.push({
        name: key,
        value: `only screen and (min-width: ${ namedQueries[key] })`
      });
    }

    this.current = this._getCurrentSize();

    this._watcher();
  },

  /**
   * Checks if the screen is at least as wide as a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to check.
   * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.
   */
  atLeast(size) {
    var query = this.get(size);

    if (query) {
      return window.matchMedia(query).matches;
    }

    return false;
  },

  /**
   * Gets the media query of a breakpoint.
   * @function
   * @param {String} size - Name of the breakpoint to get.
   * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.
   */
  get(size) {
    for (var i in this.queries) {
      var query = this.queries[i];
      if (size === query.name) return query.value;
    }

    return null;
  },

  /**
   * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).
   * @function
   * @private
   * @returns {String} Name of the current breakpoint.
   */
  _getCurrentSize() {
    var matched;

    for (var i in this.queries) {
      var query = this.queries[i];

      if (window.matchMedia(query.value).matches) {
        matched = query;
      }
    }

    if (typeof matched === 'object') {
      return matched.name;
    } else {
      return matched;
    }
  },

  /**
   * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.
   * @function
   * @private
   */
  _watcher() {
    $(window).on('resize.zf.mediaquery', () => {
      var newSize = this._getCurrentSize();

      if (newSize !== this.current) {
        // Broadcast the media query change on the window
        $(window).trigger('changed.zf.mediaquery', [newSize, this.current]);

        // Change the current media query
        this.current = newSize;
      }
    });
  }
};

Foundation.MediaQuery = MediaQuery;

// matchMedia() polyfill - Test a CSS media type/query in JS.
// Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license
window.matchMedia || (window.matchMedia = function () {
  'use strict';

  // For browsers that support matchMedium api such as IE 9 and webkit

  var styleMedia = window.styleMedia || window.media;

  // For those that don't support matchMedium
  if (!styleMedia) {
    var style = document.createElement('style'),
        script = document.getElementsByTagName('script')[0],
        info = null;

    style.type = 'text/css';
    style.id = 'matchmediajs-test';

    script.parentNode.insertBefore(style, script);

    // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
    info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;

    styleMedia = {
      matchMedium(media) {
        var text = `@media ${ media }{ #matchmediajs-test { width: 1px; } }`;

        // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
        if (style.styleSheet) {
          style.styleSheet.cssText = text;
        } else {
          style.textContent = text;
        }

        // Test if media query is true or false
        return info.width === '1px';
      }
    };
  }

  return function (media) {
    return {
      matches: styleMedia.matchMedium(media || 'all'),
      media: media || 'all'
    };
  };
}());

// Thank you: https://github.com/sindresorhus/query-string
function parseStyleToObject(str) {
  var styleObject = {};

  if (typeof str !== 'string') {
    return styleObject;
  }

  str = str.trim().slice(1, -1); // browsers re-quote string style values

  if (!str) {
    return styleObject;
  }

  styleObject = str.split('&').reduce(function (ret, param) {
    var parts = param.replace(/\+/g, ' ').split('=');
    var key = parts[0];
    var val = parts[1];
    key = decodeURIComponent(key);

    // missing `=` should be `null`:
    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
    val = val === undefined ? null : decodeURIComponent(val);

    if (!ret.hasOwnProperty(key)) {
      ret[key] = val;
    } else if (Array.isArray(ret[key])) {
      ret[key].push(val);
    } else {
      ret[key] = [ret[key], val];
    }
    return ret;
  }, {});

  return styleObject;
}

Foundation.MediaQuery = MediaQuery;
}(jQuery);
'use strict';

!function ($) {

/**
 * Motion module.
 * @module foundation.motion
 */

const initClasses = ['mui-enter', 'mui-leave'];
const activeClasses = ['mui-enter-active', 'mui-leave-active'];

const Motion = {
  animateIn: function (element, animation, cb) {
    animate(true, element, animation, cb);
  },

  animateOut: function (element, animation, cb) {
    animate(false, element, animation, cb);
  }
};

function Move(duration, elem, fn) {
  var anim,
      prog,
      start = null;
  // console.log('called');

  function move(ts) {
    if (!start) start = window.performance.now();
    // console.log(start, ts);
    prog = ts - start;
    fn.apply(elem);

    if (prog < duration) {
      anim = window.requestAnimationFrame(move, elem);
    } else {
      window.cancelAnimationFrame(anim);
      elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);
    }
  }
  anim = window.requestAnimationFrame(move);
}

/**
 * Animates an element in or out using a CSS transition class.
 * @function
 * @private
 * @param {Boolean} isIn - Defines if the animation is in or out.
 * @param {Object} element - jQuery or HTML object to animate.
 * @param {String} animation - CSS class to use.
 * @param {Function} cb - Callback to run when animation is finished.
 */
function animate(isIn, element, animation, cb) {
  element = $(element).eq(0);

  if (!element.length) return;

  var initClass = isIn ? initClasses[0] : initClasses[1];
  var activeClass = isIn ? activeClasses[0] : activeClasses[1];

  // Set up the animation
  reset();

  element.addClass(animation).css('transition', 'none');

  requestAnimationFrame(() => {
    element.addClass(initClass);
    if (isIn) element.show();
  });

  // Start the animation
  requestAnimationFrame(() => {
    element[0].offsetWidth;
    element.css('transition', '').addClass(activeClass);
  });

  // Clean up the animation when it finishes
  element.one(Foundation.transitionend(element), finish);

  // Hides the element (for out animations), resets the element, and runs a callback
  function finish() {
    if (!isIn) element.hide();
    reset();
    if (cb) cb.apply(element);
  }

  // Resets transitions and removes motion-specific classes
  function reset() {
    element[0].style.transitionDuration = 0;
    element.removeClass(`${ initClass } ${ activeClass } ${ animation }`);
  }
}

Foundation.Move = Move;
Foundation.Motion = Motion;
}(jQuery);
'use strict';

!function ($) {

const Nest = {
  Feather(menu, type = 'zf') {
    menu.attr('role', 'menubar');

    var items = menu.find('li').attr({ 'role': 'menuitem' }),
        subMenuClass = `is-${ type }-submenu`,
        subItemClass = `${ subMenuClass }-item`,
        hasSubClass = `is-${ type }-submenu-parent`;

    menu.find('a:first').attr('tabindex', 0);

    items.each(function () {
      var $item = $(this),
          $sub = $item.children('ul');

      if ($sub.length) {
        $item.addClass(hasSubClass).attr({
          'aria-haspopup': true,
          'aria-expanded': false,
          'aria-label': $item.children('a:first').text()
        });

        $sub.addClass(`submenu ${ subMenuClass }`).attr({
          'data-submenu': '',
          'aria-hidden': true,
          'role': 'menu'
        });
      }

      if ($item.parent('[data-submenu]').length) {
        $item.addClass(`is-submenu-item ${ subItemClass }`);
      }
    });

    return;
  },

  Burn(menu, type) {
    var items = menu.find('li').removeAttr('tabindex'),
        subMenuClass = `is-${ type }-submenu`,
        subItemClass = `${ subMenuClass }-item`,
        hasSubClass = `is-${ type }-submenu-parent`;

    menu.find('*').removeClass(`${ subMenuClass } ${ subItemClass } ${ hasSubClass } is-submenu-item submenu is-active`).removeAttr('data-submenu').css('display', '');

    // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')
    //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')
    //           .removeAttr('data-submenu'));
    // items.each(function(){
    //   var $item = $(this),
    //       $sub = $item.children('ul');
    //   if($item.parent('[data-submenu]').length){
    //     $item.removeClass('is-submenu-item ' + subItemClass);
    //   }
    //   if($sub.length){
    //     $item.removeClass('has-submenu');
    //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');
    //   }
    // });
  }
};

Foundation.Nest = Nest;
}(jQuery);
'use strict';

!function ($) {

function Timer(elem, options, cb) {
  var _this = this,
      duration = options.duration,
      //options is an object for easily adding features later.
  nameSpace = Object.keys(elem.data())[0] || 'timer',
      remain = -1,
      start,
      timer;

  this.isPaused = false;

  this.restart = function () {
    remain = -1;
    clearTimeout(timer);
    this.start();
  };

  this.start = function () {
    this.isPaused = false;
    // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
    clearTimeout(timer);
    remain = remain <= 0 ? duration : remain;
    elem.data('paused', false);
    start = Date.now();
    timer = setTimeout(function () {
      if (options.infinite) {
        _this.restart(); //rerun the timer.
      }
      cb();
    }, remain);
    elem.trigger(`timerstart.zf.${ nameSpace }`);
  };

  this.pause = function () {
    this.isPaused = true;
    //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.
    clearTimeout(timer);
    elem.data('paused', true);
    var end = Date.now();
    remain = remain - (end - start);
    elem.trigger(`timerpaused.zf.${ nameSpace }`);
  };
}

/**
 * Runs a callback function when images are fully loaded.
 * @param {Object} images - Image(s) to check if loaded.
 * @param {Func} callback - Function to execute when image is fully loaded.
 */
function onImagesLoaded(images, callback) {
  var self = this,
      unloaded = images.length;

  if (unloaded === 0) {
    callback();
  }

  images.each(function () {
    if (this.complete) {
      singleImageLoaded();
    } else if (typeof this.naturalWidth !== 'undefined' && this.naturalWidth > 0) {
      singleImageLoaded();
    } else {
      $(this).one('load', function () {
        singleImageLoaded();
      });
    }
  });

  function singleImageLoaded() {
    unloaded--;
    if (unloaded === 0) {
      callback();
    }
  }
}

Foundation.Timer = Timer;
Foundation.onImagesLoaded = onImagesLoaded;
}(jQuery);
//**************************************************
//**Work inspired by multiple jquery swipe plugins**
//**Done by Yohai Ararat ***************************
//**************************************************
(function ($) {

$.spotSwipe = {
  version: '1.0.0',
  enabled: 'ontouchstart' in document.documentElement,
  preventDefault: false,
  moveThreshold: 75,
  timeThreshold: 200
};

var startPosX,
    startPosY,
    startTime,
    elapsedTime,
    isMoving = false;

function onTouchEnd() {
  //  alert(this);
  this.removeEventListener('touchmove', onTouchMove);
  this.removeEventListener('touchend', onTouchEnd);
  isMoving = false;
}

function onTouchMove(e) {
  if ($.spotSwipe.preventDefault) {
    e.preventDefault();
  }
  if (isMoving) {
    var x = e.touches[0].pageX;
    var y = e.touches[0].pageY;
    var dx = startPosX - x;
    var dy = startPosY - y;
    var dir;
    elapsedTime = new Date().getTime() - startTime;
    if (Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
      dir = dx > 0 ? 'left' : 'right';
    }
    // else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {
    //   dir = dy > 0 ? 'down' : 'up';
    // }
    if (dir) {
      e.preventDefault();
      onTouchEnd.call(this);
      $(this).trigger('swipe', dir).trigger(`swipe${ dir }`);
    }
  }
}

function onTouchStart(e) {
  if (e.touches.length == 1) {
    startPosX = e.touches[0].pageX;
    startPosY = e.touches[0].pageY;
    isMoving = true;
    startTime = new Date().getTime();
    this.addEventListener('touchmove', onTouchMove, false);
    this.addEventListener('touchend', onTouchEnd, false);
  }
}

function init() {
  this.addEventListener && this.addEventListener('touchstart', onTouchStart, false);
}

function teardown() {
  this.removeEventListener('touchstart', onTouchStart);
}

$.event.special.swipe = { setup: init };

$.each(['left', 'up', 'down', 'right'], function () {
  $.event.special[`swipe${ this }`] = { setup: function () {
      $(this).on('swipe', $.noop);
    } };
});
})(jQuery);
/****************************************************
* Method for adding psuedo drag events to elements *
***************************************************/
!function ($) {
$.fn.addTouch = function () {
  this.each(function (i, el) {
    $(el).bind('touchstart touchmove touchend touchcancel', function () {
      //we pass the original event object because the jQuery event
      //object is normalized to w3c specs and does not provide the TouchList
      handleTouch(event);
    });
  });

  var handleTouch = function (event) {
    var touches = event.changedTouches,
        first = touches[0],
        eventTypes = {
      touchstart: 'mousedown',
      touchmove: 'mousemove',
      touchend: 'mouseup'
    },
        type = eventTypes[event.type],
        simulatedEvent;

    if ('MouseEvent' in window && typeof window.MouseEvent === 'function') {
      simulatedEvent = window.MouseEvent(type, {
        'bubbles': true,
        'cancelable': true,
        'screenX': first.screenX,
        'screenY': first.screenY,
        'clientX': first.clientX,
        'clientY': first.clientY
      });
    } else {
      simulatedEvent = document.createEvent('MouseEvent');
      simulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);
    }
    first.target.dispatchEvent(simulatedEvent);
  };
};
}(jQuery);

//**********************************
//**From the jQuery Mobile Library**
//**need to recreate functionality**
//**and try to improve if possible**
//**********************************

/* Removing the jQuery function ****
************************************

(function( $, window, undefined ) {

var $document = $( document ),
  // supportTouch = $.mobile.support.touch,
  touchStartEvent = 'touchstart'//supportTouch ? "touchstart" : "mousedown",
  touchStopEvent = 'touchend'//supportTouch ? "touchend" : "mouseup",
  touchMoveEvent = 'touchmove'//supportTouch ? "touchmove" : "mousemove";

// setup new event shortcuts
$.each( ( "touchstart touchmove touchend " +
  "swipe swipeleft swiperight" ).split( " " ), function( i, name ) {

  $.fn[ name ] = function( fn ) {
    return fn ? this.bind( name, fn ) : this.trigger( name );
  };

  // jQuery < 1.8
  if ( $.attrFn ) {
    $.attrFn[ name ] = true;
  }
});

function triggerCustomEvent( obj, eventType, event, bubble ) {
  var originalType = event.type;
  event.type = eventType;
  if ( bubble ) {
    $.event.trigger( event, undefined, obj );
  } else {
    $.event.dispatch.call( obj, event );
  }
  event.type = originalType;
}

// also handles taphold

// Also handles swipeleft, swiperight
$.event.special.swipe = {

  // More than this horizontal displacement, and we will suppress scrolling.
  scrollSupressionThreshold: 30,

  // More time than this, and it isn't a swipe.
  durationThreshold: 1000,

  // Swipe horizontal displacement must be more than this.
  horizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

  // Swipe vertical displacement must be less than this.
  verticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,

  getLocation: function ( event ) {
    var winPageX = window.pageXOffset,
      winPageY = window.pageYOffset,
      x = event.clientX,
      y = event.clientY;

    if ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||
      event.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {

      // iOS4 clientX/clientY have the value that should have been
      // in pageX/pageY. While pageX/page/ have the value 0
      x = x - winPageX;
      y = y - winPageY;
    } else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {

      // Some Android browsers have totally bogus values for clientX/Y
      // when scrolling/zooming a page. Detectable since clientX/clientY
      // should never be smaller than pageX/pageY minus page scroll
      x = event.pageX - winPageX;
      y = event.pageY - winPageY;
    }

    return {
      x: x,
      y: y
    };
  },

  start: function( event ) {
    var data = event.originalEvent.touches ?
        event.originalEvent.touches[ 0 ] : event,
      location = $.event.special.swipe.getLocation( data );
    return {
          time: ( new Date() ).getTime(),
          coords: [ location.x, location.y ],
          origin: $( event.target )
        };
  },

  stop: function( event ) {
    var data = event.originalEvent.touches ?
        event.originalEvent.touches[ 0 ] : event,
      location = $.event.special.swipe.getLocation( data );
    return {
          time: ( new Date() ).getTime(),
          coords: [ location.x, location.y ]
        };
  },

  handleSwipe: function( start, stop, thisObject, origTarget ) {
    if ( stop.time - start.time < $.event.special.swipe.durationThreshold &&
      Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&
      Math.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {
      var direction = start.coords[0] > stop.coords[ 0 ] ? "swipeleft" : "swiperight";

      triggerCustomEvent( thisObject, "swipe", $.Event( "swipe", { target: origTarget, swipestart: start, swipestop: stop }), true );
      triggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );
      return true;
    }
    return false;

  },

  // This serves as a flag to ensure that at most one swipe event event is
  // in work at any given time
  eventInProgress: false,

  setup: function() {
    var events,
      thisObject = this,
      $this = $( thisObject ),
      context = {};

    // Retrieve the events data for this element and add the swipe context
    events = $.data( this, "mobile-events" );
    if ( !events ) {
      events = { length: 0 };
      $.data( this, "mobile-events", events );
    }
    events.length++;
    events.swipe = context;

    context.start = function( event ) {

      // Bail if we're already working on a swipe event
      if ( $.event.special.swipe.eventInProgress ) {
        return;
      }
      $.event.special.swipe.eventInProgress = true;

      var stop,
        start = $.event.special.swipe.start( event ),
        origTarget = event.target,
        emitted = false;

      context.move = function( event ) {
        if ( !start || event.isDefaultPrevented() ) {
          return;
        }

        stop = $.event.special.swipe.stop( event );
        if ( !emitted ) {
          emitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );
          if ( emitted ) {

            // Reset the context to make way for the next swipe event
            $.event.special.swipe.eventInProgress = false;
          }
        }
        // prevent scrolling
        if ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {
          event.preventDefault();
        }
      };

      context.stop = function() {
          emitted = true;

          // Reset the context to make way for the next swipe event
          $.event.special.swipe.eventInProgress = false;
          $document.off( touchMoveEvent, context.move );
          context.move = null;
      };

      $document.on( touchMoveEvent, context.move )
        .one( touchStopEvent, context.stop );
    };
    $this.on( touchStartEvent, context.start );
  },

  teardown: function() {
    var events, context;

    events = $.data( this, "mobile-events" );
    if ( events ) {
      context = events.swipe;
      delete events.swipe;
      events.length--;
      if ( events.length === 0 ) {
        $.removeData( this, "mobile-events" );
      }
    }

    if ( context ) {
      if ( context.start ) {
        $( this ).off( touchStartEvent, context.start );
      }
      if ( context.move ) {
        $document.off( touchMoveEvent, context.move );
      }
      if ( context.stop ) {
        $document.off( touchStopEvent, context.stop );
      }
    }
  }
};
$.each({
  swipeleft: "swipe.left",
  swiperight: "swipe.right"
}, function( event, sourceEvent ) {

  $.event.special[ event ] = {
    setup: function() {
      $( this ).bind( sourceEvent, $.noop );
    },
    teardown: function() {
      $( this ).unbind( sourceEvent );
    }
  };
});
})( jQuery, this );
*/
'use strict';

!function ($) {

const MutationObserver = function () {
  var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
  for (var i = 0; i < prefixes.length; i++) {
    if (`${ prefixes[i] }MutationObserver` in window) {
      return window[`${ prefixes[i] }MutationObserver`];
    }
  }
  return false;
}();

const triggers = (el, type) => {
  el.data(type).split(' ').forEach(id => {
    $(`#${ id }`)[type === 'close' ? 'trigger' : 'triggerHandler'](`${ type }.zf.trigger`, [el]);
  });
};
// Elements with [data-open] will reveal a plugin that supports it when clicked.
$(document).on('click.zf.trigger', '[data-open]', function () {
  triggers($(this), 'open');
});

// Elements with [data-close] will close a plugin that supports it when clicked.
// If used without a value on [data-close], the event will bubble, allowing it to close a parent component.
$(document).on('click.zf.trigger', '[data-close]', function () {
  let id = $(this).data('close');
  if (id) {
    triggers($(this), 'close');
  } else {
    $(this).trigger('close.zf.trigger');
  }
});

// Elements with [data-toggle] will toggle a plugin that supports it when clicked.
$(document).on('click.zf.trigger', '[data-toggle]', function () {
  triggers($(this), 'toggle');
});

// Elements with [data-closable] will respond to close.zf.trigger events.
$(document).on('close.zf.trigger', '[data-closable]', function (e) {
  e.stopPropagation();
  let animation = $(this).data('closable');

  if (animation !== '') {
    Foundation.Motion.animateOut($(this), animation, function () {
      $(this).trigger('closed.zf');
    });
  } else {
    $(this).fadeOut().trigger('closed.zf');
  }
});

$(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {
  let id = $(this).data('toggle-focus');
  $(`#${ id }`).triggerHandler('toggle.zf.trigger', [$(this)]);
});

/**
* Fires once after all other scripts have loaded
* @function
* @private
*/
$(window).load(() => {
  checkListeners();
});

function checkListeners() {
  eventsListener();
  resizeListener();
  scrollListener();
  closemeListener();
}

//******** only fires this function once on load, if there's something to watch ********
function closemeListener(pluginName) {
  var yetiBoxes = $('[data-yeti-box]'),
      plugNames = ['dropdown', 'tooltip', 'reveal'];

  if (pluginName) {
    if (typeof pluginName === 'string') {
      plugNames.push(pluginName);
    } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {
      plugNames.concat(pluginName);
    } else {
      console.error('Plugin names must be strings');
    }
  }
  if (yetiBoxes.length) {
    let listeners = plugNames.map(name => {
      return `closeme.zf.${ name }`;
    }).join(' ');

    $(window).off(listeners).on(listeners, function (e, pluginId) {
      let plugin = e.namespace.split('.')[0];
      let plugins = $(`[data-${ plugin }]`).not(`[data-yeti-box="${ pluginId }"]`);

      plugins.each(function () {
        let _this = $(this);

        _this.triggerHandler('close.zf.trigger', [_this]);
      });
    });
  }
}

function resizeListener(debounce) {
  let timer,
      $nodes = $('[data-resize]');
  if ($nodes.length) {
    $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {
      if (timer) {
        clearTimeout(timer);
      }

      timer = setTimeout(function () {

        if (!MutationObserver) {
          //fallback for IE 9
          $nodes.each(function () {
            $(this).triggerHandler('resizeme.zf.trigger');
          });
        }
        //trigger all listening elements and signal a resize event
        $nodes.attr('data-events', "resize");
      }, debounce || 10); //default time to emit resize event
    });
  }
}

function scrollListener(debounce) {
  let timer,
      $nodes = $('[data-scroll]');
  if ($nodes.length) {
    $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {
      if (timer) {
        clearTimeout(timer);
      }

      timer = setTimeout(function () {

        if (!MutationObserver) {
          //fallback for IE 9
          $nodes.each(function () {
            $(this).triggerHandler('scrollme.zf.trigger');
          });
        }
        //trigger all listening elements and signal a scroll event
        $nodes.attr('data-events', "scroll");
      }, debounce || 10); //default time to emit scroll event
    });
  }
}

function eventsListener() {
  if (!MutationObserver) {
    return false;
  }
  let nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');

  //element callback
  var listeningElementsMutation = function (mutationRecordsList) {
    var $target = $(mutationRecordsList[0].target);
    //trigger the event handler for the element depending on type
    switch ($target.attr("data-events")) {

      case "resize":
        $target.triggerHandler('resizeme.zf.trigger', [$target]);
        break;

      case "scroll":
        $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);
        break;

      // case "mutate" :
      // console.log('mutate', $target);
      // $target.triggerHandler('mutate.zf.trigger');
      //
      // //make sure we don't get stuck in an infinite loop from sloppy codeing
      // if ($target.index('[data-mutate]') == $("[data-mutate]").length-1) {
      //   domMutationObserver();
      // }
      // break;

      default:
        return false;
      //nothing
    }
  };

  if (nodes.length) {
    //for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer
    for (var i = 0; i <= nodes.length - 1; i++) {
      let elementObserver = new MutationObserver(listeningElementsMutation);
      elementObserver.observe(nodes[i], { attributes: true, childList: false, characterData: false, subtree: false, attributeFilter: ["data-events"] });
    }
  }
}

// ------------------------------------

// [PH]
// Foundation.CheckWatchers = checkWatchers;
Foundation.IHearYou = checkListeners;
// Foundation.ISeeYou = scrollListener;
// Foundation.IFeelYou = closemeListener;
}(jQuery);

// function domMutationObserver(debounce) {
//   // !!! This is coming soon and needs more work; not active  !!! //
//   var timer,
//   nodes = document.querySelectorAll('[data-mutate]');
//   //
//   if (nodes.length) {
//     // var MutationObserver = (function () {
//     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];
//     //   for (var i=0; i < prefixes.length; i++) {
//     //     if (prefixes[i] + 'MutationObserver' in window) {
//     //       return window[prefixes[i] + 'MutationObserver'];
//     //     }
//     //   }
//     //   return false;
//     // }());
//
//
//     //for the body, we need to listen for all changes effecting the style and class attributes
//     var bodyObserver = new MutationObserver(bodyMutation);
//     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:["style", "class"]});
//
//
//     //body callback
//     function bodyMutation(mutate) {
//       //trigger all listening elements and signal a mutation event
//       if (timer) { clearTimeout(timer); }
//
//       timer = setTimeout(function() {
//         bodyObserver.disconnect();
//         $('[data-mutate]').attr('data-events',"mutate");
//       }, debounce || 150);
//     }
//   }
// }
'use strict';

!function ($) {

/**
 * AccordionMenu module.
 * @module foundation.accordionMenu
 * @requires foundation.util.keyboard
 * @requires foundation.util.motion
 * @requires foundation.util.nest
 */

class AccordionMenu {
  /**
   * Creates a new instance of an accordion menu.
   * @class
   * @fires AccordionMenu#init
   * @param {jQuery} element - jQuery object to make into an accordion menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  constructor(element, options) {
    this.$element = element;
    this.options = $.extend({}, AccordionMenu.defaults, this.$element.data(), options);

    Foundation.Nest.Feather(this.$element, 'accordion');

    this._init();

    Foundation.registerPlugin(this, 'AccordionMenu');
    Foundation.Keyboard.register('AccordionMenu', {
      'ENTER': 'toggle',
      'SPACE': 'toggle',
      'ARROW_RIGHT': 'open',
      'ARROW_UP': 'up',
      'ARROW_DOWN': 'down',
      'ARROW_LEFT': 'close',
      'ESCAPE': 'closeAll',
      'TAB': 'down',
      'SHIFT_TAB': 'up'
    });
  }

  /**
   * Initializes the accordion menu by hiding all nested menus.
   * @private
   */
  _init() {
    this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');
    this.$element.attr({
      'role': 'tablist',
      'aria-multiselectable': this.options.multiOpen
    });

    this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');
    this.$menuLinks.each(function () {
      var linkId = this.id || Foundation.GetYoDigits(6, 'acc-menu-link'),
          $elem = $(this),
          $sub = $elem.children('[data-submenu]'),
          subId = $sub[0].id || Foundation.GetYoDigits(6, 'acc-menu'),
          isActive = $sub.hasClass('is-active');
      $elem.attr({
        'aria-controls': subId,
        'aria-expanded': isActive,
        'role': 'tab',
        'id': linkId
      });
      $sub.attr({
        'aria-labelledby': linkId,
        'aria-hidden': !isActive,
        'role': 'tabpanel',
        'id': subId
      });
    });
    var initPanes = this.$element.find('.is-active');
    if (initPanes.length) {
      var _this = this;
      initPanes.each(function () {
        _this.down($(this));
      });
    }
    this._events();
  }

  /**
   * Adds event handlers for items within the menu.
   * @private
   */
  _events() {
    var _this = this;

    this.$element.find('li').each(function () {
      var $submenu = $(this).children('[data-submenu]');

      if ($submenu.length) {
        $(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {
          e.preventDefault();

          _this.toggle($submenu);
        });
      }
    }).on('keydown.zf.accordionmenu', function (e) {
      var $element = $(this),
          $elements = $element.parent('ul').children('li'),
          $prevElement,
          $nextElement,
          $target = $element.children('[data-submenu]');

      $elements.each(function (i) {
        if ($(this).is($element)) {
          $prevElement = $elements.eq(Math.max(0, i - 1));
          $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));

          if ($(this).children('[data-submenu]:visible').length) {
            // has open sub menu
            $nextElement = $element.find('li:first-child');
          }
          if ($(this).is(':first-child')) {
            // is first element of sub menu
            $prevElement = $element.parents('li').first();
          } else if ($prevElement.children('[data-submenu]:visible').length) {
            // if previous element has open sub menu
            $prevElement = $prevElement.find('li:last-child');
          }
          if ($(this).is(':last-child')) {
            // is last element of sub menu
            $nextElement = $element.parents('li').first().next('li');
          }

          return;
        }
      });
      Foundation.Keyboard.handleKey(e, 'AccordionMenu', {
        open: function () {
          if ($target.is(':hidden')) {
            _this.down($target);
            $target.find('li').first().focus();
          }
        },
        close: function () {
          if ($target.length && !$target.is(':hidden')) {
            // close active sub of this item
            _this.up($target);
          } else if ($element.parent('[data-submenu]').length) {
            // close currently open sub
            _this.up($element.parent('[data-submenu]'));
            $element.parents('li').first().focus();
          }
        },
        up: function () {
          $prevElement.focus();
        },
        down: function () {
          $nextElement.focus();
        },
        toggle: function () {
          if ($element.children('[data-submenu]').length) {
            _this.toggle($element.children('[data-submenu]'));
          }
        },
        closeAll: function () {
          _this.hideAll();
        },
        handled: function () {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
      });
    }); //.attr('tabindex', 0);
  }

  /**
   * Closes all panes of the menu.
   * @function
   */
  hideAll() {
    this.$element.find('[data-submenu]').slideUp(this.options.slideSpeed);
  }

  /**
   * Toggles the open/close state of a submenu.
   * @function
   * @param {jQuery} $target - the submenu to toggle
   */
  toggle($target) {
    if (!$target.is(':animated')) {
      if (!$target.is(':hidden')) {
        this.up($target);
      } else {
        this.down($target);
      }
    }
  }

  /**
   * Opens the sub-menu defined by `$target`.
   * @param {jQuery} $target - Sub-menu to open.
   * @fires AccordionMenu#down
   */
  down($target) {
    var _this = this;

    if (!this.options.multiOpen) {
      this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));
    }

    $target.addClass('is-active').attr({ 'aria-hidden': false }).parent('.is-accordion-submenu-parent').attr({ 'aria-expanded': true });

    Foundation.Move(this.options.slideSpeed, $target, function () {
      $target.slideDown(_this.options.slideSpeed, function () {
        /**
         * Fires when the menu is done opening.
         * @event AccordionMenu#down
         */
        _this.$element.trigger('down.zf.accordionMenu', [$target]);
      });
    });
  }

  /**
   * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.
   * @param {jQuery} $target - Sub-menu to close.
   * @fires AccordionMenu#up
   */
  up($target) {
    var _this = this;
    Foundation.Move(this.options.slideSpeed, $target, function () {
      $target.slideUp(_this.options.slideSpeed, function () {
        /**
         * Fires when the menu is done collapsing up.
         * @event AccordionMenu#up
         */
        _this.$element.trigger('up.zf.accordionMenu', [$target]);
      });
    });

    var $menus = $target.find('[data-submenu]').slideUp(0).addBack().attr('aria-hidden', true);

    $menus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);
  }

  /**
   * Destroys an instance of accordion menu.
   * @fires AccordionMenu#destroyed
   */
  destroy() {
    this.$element.find('[data-submenu]').slideDown(0).css('display', '');
    this.$element.find('a').off('click.zf.accordionMenu');

    Foundation.Nest.Burn(this.$element, 'accordion');
    Foundation.unregisterPlugin(this);
  }
}

AccordionMenu.defaults = {
  /**
   * Amount of time to animate the opening of a submenu in ms.
   * @option
   * @example 250
   */
  slideSpeed: 250,
  /**
   * Allow the menu to have multiple open panes.
   * @option
   * @example true
   */
  multiOpen: true
};

// Window exports
Foundation.plugin(AccordionMenu, 'AccordionMenu');
}(jQuery);
'use strict';

!function ($) {

/**
 * Drilldown module.
 * @module foundation.drilldown
 * @requires foundation.util.keyboard
 * @requires foundation.util.motion
 * @requires foundation.util.nest
 */

class Drilldown {
  /**
   * Creates a new instance of a drilldown menu.
   * @class
   * @param {jQuery} element - jQuery object to make into an accordion menu.
   * @param {Object} options - Overrides to the default plugin settings.
   */
  constructor(element, options) {
    this.$element = element;
    this.options = $.extend({}, Drilldown.defaults, this.$element.data(), options);

    Foundation.Nest.Feather(this.$element, 'drilldown');

    this._init();

    Foundation.registerPlugin(this, 'Drilldown');
    Foundation.Keyboard.register('Drilldown', {
      'ENTER': 'open',
      'SPACE': 'open',
      'ARROW_RIGHT': 'next',
      'ARROW_UP': 'up',
      'ARROW_DOWN': 'down',
      'ARROW_LEFT': 'previous',
      'ESCAPE': 'close',
      'TAB': 'down',
      'SHIFT_TAB': 'up'
    });
  }

  /**
   * Initializes the drilldown by creating jQuery collections of elements
   * @private
   */
  _init() {
    this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent');
    this.$submenus = this.$submenuAnchors.children('[data-submenu]');
    this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'menuitem');

    this._prepareMenu();

    this._keyboardEvents();
  }

  /**
   * prepares drilldown menu by setting attributes to links and elements
   * sets a min height to prevent content jumping
   * wraps the element if not already wrapped
   * @private
   * @function
   */
  _prepareMenu() {
    var _this = this;
    // if(!this.options.holdOpen){
    //   this._menuLinkEvents();
    // }
    this.$submenuAnchors.each(function () {
      var $sub = $(this);
      var $link = $sub.find('a:first');
      if (_this.options.parentLink) {
        $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li class="is-submenu-parent-item is-submenu-item is-drilldown-submenu-item" role="menu-item"></li>');
      }
      $link.data('savedHref', $link.attr('href')).removeAttr('href');
      $sub.children('[data-submenu]').attr({
        'aria-hidden': true,
        'tabindex': 0,
        'role': 'menu'
      });
      _this._events($sub);
    });
    this.$submenus.each(function () {
      var $menu = $(this),
          $back = $menu.find('.js-drilldown-back');
      if (!$back.length) {
        $menu.prepend(_this.options.backButton);
      }
      _this._back($menu);
    });
    if (!this.$element.parent().hasClass('is-drilldown')) {
      this.$wrapper = $(this.options.wrapper).addClass('is-drilldown').css(this._getMaxDims());
      this.$element.wrap(this.$wrapper);
    }
  }

  /**
   * Adds event handlers to elements in the menu.
   * @function
   * @private
   * @param {jQuery} $elem - the current menu item to add handlers to.
   */
  _events($elem) {
    var _this = this;

    $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
      if ($(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {
        e.stopImmediatePropagation();
        e.preventDefault();
      }

      // if(e.target !== e.currentTarget.firstElementChild){
      //   return false;
      // }
      _this._show($elem);

      if (_this.options.closeOnClick) {
        var $body = $('body').not(_this.$wrapper);
        $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {
          e.preventDefault();
          _this._hideAll();
          $body.off('.zf.drilldown');
        });
      }
    });
  }

  /**
   * Adds keydown event listener to `li`'s in the menu.
   * @private
   */
  _keyboardEvents() {
    var _this = this;
    this.$menuItems.add(this.$element.find('.js-drilldown-back')).on('keydown.zf.drilldown', function (e) {
      var $element = $(this),
          $elements = $element.parent('ul').children('li'),
          $prevElement,
          $nextElement;

      $elements.each(function (i) {
        if ($(this).is($element)) {
          $prevElement = $elements.eq(Math.max(0, i - 1));
          $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));
          return;
        }
      });
      Foundation.Keyboard.handleKey(e, 'Drilldown', {
        next: function () {
          if ($element.is(_this.$submenuAnchors)) {
            _this._show($element);
            $element.on(Foundation.transitionend($element), function () {
              $element.find('ul li').filter(_this.$menuItems).first().focus();
            });
          }
        },
        previous: function () {
          _this._hide($element.parent('ul'));
          $element.parent('ul').on(Foundation.transitionend($element), function () {
            setTimeout(function () {
              $element.parent('ul').parent('li').focus();
            }, 1);
          });
        },
        up: function () {
          $prevElement.focus();
        },
        down: function () {
          $nextElement.focus();
        },
        close: function () {
          _this._back();
          //_this.$menuItems.first().focus(); // focus to first element
        },
        open: function () {
          if (!$element.is(_this.$menuItems)) {
            // not menu item means back button
            _this._hide($element.parent('ul'));
            setTimeout(function () {
              $element.parent('ul').parent('li').focus();
            }, 1);
          } else if ($element.is(_this.$submenuAnchors)) {
            _this._show($element);
            setTimeout(function () {
              $element.find('ul li').filter(_this.$menuItems).first().focus();
            }, 1);
          }
        },
        handled: function () {
          e.preventDefault();
          e.stopImmediatePropagation();
        }
      });
    }); // end keyboardAccess
  }

  /**
   * Closes all open elements, and returns to root menu.
   * @function
   * @fires Drilldown#closed
   */
  _hideAll() {
    var $elem = this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');
    $elem.one(Foundation.transitionend($elem), function (e) {
      $elem.removeClass('is-active is-closing');
    });
    /**
     * Fires when the menu is fully closed.
     * @event Drilldown#closed
     */
    this.$element.trigger('closed.zf.drilldown');
  }

  /**
   * Adds event listener for each `back` button, and closes open menus.
   * @function
   * @fires Drilldown#back
   * @param {jQuery} $elem - the current sub-menu to add `back` event.
   */
  _back($elem) {
    var _this = this;
    $elem.off('click.zf.drilldown');
    $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {
      e.stopImmediatePropagation();
      // console.log('mouseup on back');
      _this._hide($elem);
    });
  }

  /**
   * Adds event listener to menu items w/o submenus to close open menus on click.
   * @function
   * @private
   */
  _menuLinkEvents() {
    var _this = this;
    this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {
      // e.stopImmediatePropagation();
      setTimeout(function () {
        _this._hideAll();
      }, 0);
    });
  }

  /**
   * Opens a submenu.
   * @function
   * @fires Drilldown#open
   * @param {jQuery} $elem - the current element with a submenu to open.
   */
  _show($elem) {
    $elem.children('[data-submenu]').addClass('is-active');

    this.$element.trigger('open.zf.drilldown', [$elem]);
  }

  /**
   * Hides a submenu
   * @function
   * @fires Drilldown#hide
   * @param {jQuery} $elem - the current sub-menu to hide.
   */
  _hide($elem) {
    var _this = this;
    $elem.addClass('is-closing').one(Foundation.transitionend($elem), function () {
      $elem.removeClass('is-active is-closing');
      $elem.blur();
    });
    /**
     * Fires when the submenu is has closed.
     * @event Drilldown#hide
     */
    $elem.trigger('hide.zf.drilldown', [$elem]);
  }

  /**
   * Iterates through the nested menus to calculate the min-height, and max-width for the menu.
   * Prevents content jumping.
   * @function
   * @private
   */
  _getMaxDims() {
    var max = 0,
        result = {};
    this.$submenus.add(this.$element).each(function () {
      var numOfElems = $(this).children('li').length;
      max = numOfElems > max ? numOfElems : max;
    });

    result['min-height'] = `${ max * this.$menuItems[0].getBoundingClientRect().height }px`;
    result['max-width'] = `${ this.$element[0].getBoundingClientRect().width }px`;

    return result;
  }

  /**
   * Destroys the Drilldown Menu
   * @function
   */
  destroy() {
    this._hideAll();
    Foundation.Nest.Burn(this.$element, 'drilldown');
    this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role').off('.zf.drilldown').end().off('zf.drilldown');
    this.$element.find('a').each(function () {
      var $link = $(this);
      if ($link.data('savedHref')) {
        $link.attr('href', $link.data('savedHref')).removeData('savedHref');
      } else {
        return;
      }
    });
    Foundation.unregisterPlugin(this);
  }
}

Drilldown.defaults = {
  /**
   * Markup used for JS generated back button. Prepended to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\`) if copy and pasting.
   * @option
   * @example '<\li><\a>Back<\/a><\/li>'
   */
  backButton: '<li class="js-drilldown-back"><a>Back</a></li>',
  /**
   * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\`) if copy and pasting.
   * @option
   * @example '<\div class="is-drilldown"><\/div>'
   */
  wrapper: '<div></div>',
  /**
   * Adds the parent link to the submenu.
   * @option
   * @example false
   */
  parentLink: false,
  /**
   * Allow the menu to return to root list on body click.
   * @option
   * @example false
   */
  closeOnClick: false
  // holdOpen: false
};

// Window exports
Foundation.plugin(Drilldown, 'Drilldown');
}(jQuery);
'use strict';

!function ($) {

/**
 * Reveal module.
 * @module foundation.reveal
 * @requires foundation.util.keyboard
 * @requires foundation.util.box
 * @requires foundation.util.triggers
 * @requires foundation.util.mediaQuery
 * @requires foundation.util.motion if using animations
 */

class Reveal {
  /**
   * Creates a new instance of Reveal.
   * @class
   * @param {jQuery} element - jQuery object to use for the modal.
   * @param {Object} options - optional parameters.
   */
  constructor(element, options) {
    this.$element = element;
    this.options = $.extend({}, Reveal.defaults, this.$element.data(), options);
    this._init();

    Foundation.registerPlugin(this, 'Reveal');
    Foundation.Keyboard.register('Reveal', {
      'ENTER': 'open',
      'SPACE': 'open',
      'ESCAPE': 'close',
      'TAB': 'tab_forward',
      'SHIFT_TAB': 'tab_backward'
    });
  }

  /**
   * Initializes the modal by adding the overlay and close buttons, (if selected).
   * @private
   */
  _init() {
    this.id = this.$element.attr('id');
    this.isActive = false;
    this.cached = { mq: Foundation.MediaQuery.current };
    this.isiOS = iPhoneSniff();

    if (this.isiOS) {
      this.$element.addClass('is-ios');
    }

    this.$anchor = $(`[data-open="${ this.id }"]`).length ? $(`[data-open="${ this.id }"]`) : $(`[data-toggle="${ this.id }"]`);

    if (this.$anchor.length) {
      var anchorId = this.$anchor[0].id || Foundation.GetYoDigits(6, 'reveal');

      this.$anchor.attr({
        'aria-controls': this.id,
        'id': anchorId,
        'aria-haspopup': true,
        'tabindex': 0
      });
      this.$element.attr({ 'aria-labelledby': anchorId });
    }

    if (this.options.fullScreen || this.$element.hasClass('full')) {
      this.options.fullScreen = true;
      this.options.overlay = false;
    }
    if (this.options.overlay && !this.$overlay) {
      this.$overlay = this._makeOverlay(this.id);
    }

    this.$element.attr({
      'role': 'dialog',
      'aria-hidden': true,
      'data-yeti-box': this.id,
      'data-resize': this.id
    });

    if (this.$overlay) {
      this.$element.detach().appendTo(this.$overlay);
    } else {
      this.$element.detach().appendTo($('body'));
      this.$element.addClass('without-overlay');
    }
    this._events();
    if (this.options.deepLink && window.location.hash === `#${ this.id }`) {
      $(window).one('load.zf.reveal', this.open.bind(this));
    }
  }

  /**
   * Creates an overlay div to display behind the modal.
   * @private
   */
  _makeOverlay(id) {
    var $overlay = $('<div></div>').addClass('reveal-overlay').attr({ 'tabindex': -1, 'aria-hidden': true }).appendTo('body');
    return $overlay;
  }

  /**
   * Updates position of modal
   * TODO:  Figure out if we actually need to cache these values or if it doesn't matter
   * @private
   */
  _updatePosition() {
    var width = this.$element.outerWidth();
    var outerWidth = $(window).width();
    var height = this.$element.outerHeight();
    var outerHeight = $(window).height();
    var left = parseInt((outerWidth - width) / 2, 10);
    var top;
    if (height > outerHeight) {
      top = parseInt(Math.min(100, outerHeight / 10), 10);
    } else {
      top = parseInt((outerHeight - height) / 4, 10);
    }
    this.$element.css({ top: top + 'px' });
    // only worry about left if we don't have an overlay, otherwise we're perfectly in the middle
    if (!this.$overlay) {
      this.$element.css({ left: left + 'px' });
    }
  }

  /**
   * Adds event handlers for the modal.
   * @private
   */
  _events() {
    var _this = this;

    this.$element.on({
      'open.zf.trigger': this.open.bind(this),
      'close.zf.trigger': this.close.bind(this),
      'toggle.zf.trigger': this.toggle.bind(this),
      'resizeme.zf.trigger': function () {
        _this._updatePosition();
      }
    });

    if (this.$anchor.length) {
      this.$anchor.on('keydown.zf.reveal', function (e) {
        if (e.which === 13 || e.which === 32) {
          e.stopPropagation();
          e.preventDefault();
          _this.open();
        }
      });
    }

    if (this.options.closeOnClick && this.options.overlay) {
      this.$overlay.off('.zf.reveal').on('click.zf.reveal', function (e) {
        if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {
          return;
        }
        _this.close();
      });
    }
    if (this.options.deepLink) {
      $(window).on(`popstate.zf.reveal:${ this.id }`, this._handleState.bind(this));
    }
  }

  /**
   * Handles modal methods on back/forward button clicks or any other event that triggers popstate.
   * @private
   */
  _handleState(e) {
    if (window.location.hash === '#' + this.id && !this.isActive) {
      this.open();
    } else {
      this.close();
    }
  }

  /**
   * Opens the modal controlled by `this.$anchor`, and closes all others by default.
   * @function
   * @fires Reveal#closeme
   * @fires Reveal#open
   */
  open() {
    if (this.options.deepLink) {
      var hash = `#${ this.id }`;

      if (window.history.pushState) {
        window.history.pushState(null, null, hash);
      } else {
        window.location.hash = hash;
      }
    }

    this.isActive = true;

    // Make elements invisible, but remove display: none so we can get size and positioning
    this.$element.css({ 'visibility': 'hidden' }).show().scrollTop(0);
    if (this.options.overlay) {
      this.$overlay.css({ 'visibility': 'hidden' }).show();
    }

    this._updatePosition();

    this.$element.hide().css({ 'visibility': '' });

    if (this.$overlay) {
      this.$overlay.css({ 'visibility': '' }).hide();
    }

    if (!this.options.multipleOpened) {
      /**
       * Fires immediately before the modal opens.
       * Closes any other modals that are currently open
       * @event Reveal#closeme
       */
      this.$element.trigger('closeme.zf.reveal', this.id);
    }

    // Motion UI method of reveal
    if (this.options.animationIn) {
      if (this.options.overlay) {
        Foundation.Motion.animateIn(this.$overlay, 'fade-in');
      }
      Foundation.Motion.animateIn(this.$element, this.options.animationIn, function () {
        this.focusableElements = Foundation.Keyboard.findFocusable(this.$element);
      });
    }
    // jQuery method of reveal
    else {
        if (this.options.overlay) {
          this.$overlay.show(0);
        }
        this.$element.show(this.options.showDelay);
      }

    // handle accessibility
    this.$element.attr({
      'aria-hidden': false,
      'tabindex': -1
    }).focus();

    /**
     * Fires when the modal has successfully opened.
     * @event Reveal#open
     */
    this.$element.trigger('open.zf.reveal');

    if (this.isiOS) {
      var scrollPos = window.pageYOffset;
      $('html, body').addClass('is-reveal-open').scrollTop(scrollPos);
    } else {
      $('body').addClass('is-reveal-open');
    }

    $('body').addClass('is-reveal-open').attr('aria-hidden', this.options.overlay || this.options.fullScreen ? true : false);

    setTimeout(() => {
      this._extraHandlers();
    }, 0);
  }

  /**
   * Adds extra event handlers for the body and window if necessary.
   * @private
   */
  _extraHandlers() {
    var _this = this;
    this.focusableElements = Foundation.Keyboard.findFocusable(this.$element);

    if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {
      $('body').on('click.zf.reveal', function (e) {
        if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {
          return;
        }
        _this.close();
      });
    }

    if (this.options.closeOnEsc) {
      $(window).on('keydown.zf.reveal', function (e) {
        Foundation.Keyboard.handleKey(e, 'Reveal', {
          close: function () {
            if (_this.options.closeOnEsc) {
              _this.close();
              _this.$anchor.focus();
            }
          }
        });
        if (_this.focusableElements.length === 0) {
          // no focusable elements inside the modal at all, prevent tabbing in general
          e.preventDefault();
        }
      });
    }

    // lock focus within modal while tabbing
    this.$element.on('keydown.zf.reveal', function (e) {
      var $target = $(this);
      // handle keyboard event with keyboard util
      Foundation.Keyboard.handleKey(e, 'Reveal', {
        tab_forward: function () {
          if (_this.$element.find(':focus').is(_this.focusableElements.eq(-1))) {
            // left modal downwards, setting focus to first element
            _this.focusableElements.eq(0).focus();
            e.preventDefault();
          }
        },
        tab_backward: function () {
          if (_this.$element.find(':focus').is(_this.focusableElements.eq(0)) || _this.$element.is(':focus')) {
            // left modal upwards, setting focus to last element
            _this.focusableElements.eq(-1).focus();
            e.preventDefault();
          }
        },
        open: function () {
          if (_this.$element.find(':focus').is(_this.$element.find('[data-close]'))) {
            setTimeout(function () {
              // set focus back to anchor if close button has been activated
              _this.$anchor.focus();
            }, 1);
          } else if ($target.is(_this.focusableElements)) {
            // dont't trigger if acual element has focus (i.e. inputs, links, ...)
            _this.open();
          }
        },
        close: function () {
          if (_this.options.closeOnEsc) {
            _this.close();
            _this.$anchor.focus();
          }
        }
      });
    });
  }

  /**
   * Closes the modal.
   * @function
   * @fires Reveal#closed
   */
  close() {
    if (!this.isActive || !this.$element.is(':visible')) {
      return false;
    }
    var _this = this;

    // Motion UI method of hiding
    if (this.options.animationOut) {
      if (this.options.overlay) {
        Foundation.Motion.animateOut(this.$overlay, 'fade-out', finishUp);
      } else {
        finishUp();
      }

      Foundation.Motion.animateOut(this.$element, this.options.animationOut);
    }
    // jQuery method of hiding
    else {
        if (this.options.overlay) {
          this.$overlay.hide(0, finishUp);
        } else {
          finishUp();
        }

        this.$element.hide(this.options.hideDelay);
      }

    // Conditionals to remove extra event listeners added on open
    if (this.options.closeOnEsc) {
      $(window).off('keydown.zf.reveal');
    }

    if (!this.options.overlay && this.options.closeOnClick) {
      $('body').off('click.zf.reveal');
    }

    this.$element.off('keydown.zf.reveal');

    function finishUp() {
      if (_this.isiOS) {
        $('html, body').removeClass('is-reveal-open');
      } else {
        $('body').removeClass('is-reveal-open');
      }

      $('body').attr({
        'aria-hidden': false,
        'tabindex': ''
      });

      _this.$element.attr('aria-hidden', true);

      /**
      * Fires when the modal is done closing.
      * @event Reveal#closed
      */
      _this.$element.trigger('closed.zf.reveal');
    }

    /**
    * Resets the modal content
    * This prevents a running video to keep going in the background
    */
    if (this.options.resetOnClose) {
      this.$element.html(this.$element.html());
    }

    this.isActive = false;
    if (_this.options.deepLink) {
      if (window.history.replaceState) {
        window.history.replaceState("", document.title, window.location.pathname);
      } else {
        window.location.hash = '';
      }
    }
  }

  /**
   * Toggles the open/closed state of a modal.
   * @function
   */
  toggle() {
    if (this.isActive) {
      this.close();
    } else {
      this.open();
    }
  }

  /**
   * Destroys an instance of a modal.
   * @function
   */
  destroy() {
    if (this.options.overlay) {
      this.$overlay.hide().off().remove();
    }
    this.$element.hide().off();
    this.$anchor.off('.zf');
    $(window).off(`.zf.reveal:${ this.id }`);

    Foundation.unregisterPlugin(this);
  }
}

Reveal.defaults = {
  /**
   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
   * @option
   * @example 'slide-in-left'
   */
  animationIn: '',
  /**
   * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.
   * @option
   * @example 'slide-out-right'
   */
  animationOut: '',
  /**
   * Time, in ms, to delay the opening of a modal after a click if no animation used.
   * @option
   * @example 10
   */
  showDelay: 0,
  /**
   * Time, in ms, to delay the closing of a modal after a click if no animation used.
   * @option
   * @example 10
   */
  hideDelay: 0,
  /**
   * Allows a click on the body/overlay to close the modal.
   * @option
   * @example true
   */
  closeOnClick: true,
  /**
   * Allows the modal to close if the user presses the `ESCAPE` key.
   * @option
   * @example true
   */
  closeOnEsc: true,
  /**
   * If true, allows multiple modals to be displayed at once.
   * @option
   * @example false
   */
  multipleOpened: false,
  /**
   * Distance, in pixels, the modal should push down from the top of the screen.
   * @option
   * @example 100
   */
  vOffset: 100,
  /**
   * Distance, in pixels, the modal should push in from the side of the screen.
   * @option
   * @example 0
   */
  hOffset: 0,
  /**
   * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.
   * @option
   * @example false
   */
  fullScreen: false,
  /**
   * Percentage of screen height the modal should push up from the bottom of the view.
   * @option
   * @example 10
   */
  btmOffsetPct: 10,
  /**
   * Allows the modal to generate an overlay div, which will cover the view when modal opens.
   * @option
   * @example true
   */
  overlay: true,
  /**
   * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.
   * @option
   * @example false
   */
  resetOnClose: false,
  /**
   * Allows the modal to alter the url on open/close, and allows the use of the `back` button to close modals. ALSO, allows a modal to auto-maniacally open on page load IF the hash === the modal's user-set id.
   * @option
   * @example false
   */
  deepLink: false
};

// Window exports
Foundation.plugin(Reveal, 'Reveal');

function iPhoneSniff() {
  return (/iP(ad|hone|od).*OS/.test(window.navigator.userAgent)
  );
}
}(jQuery);

</script>


  </body>

</html>
